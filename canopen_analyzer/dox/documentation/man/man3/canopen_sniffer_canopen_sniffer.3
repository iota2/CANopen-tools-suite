.TH "canopen_sniffer" 3 "Sat Jan 3 2026" "CANopen-Analyzer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
canopen_sniffer \- CANopen bus sniffer thread\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits Thread\&.
.SH "Detailed Description"
.PP 
CANopen bus sniffer thread\&. 

The sniffer opens a \fCsocketcan\fP interface, receives \fCcan\&.Message\fP frames, enqueues them on \fCraw_frame\fP for downstream processing, and optionally writes raw frames to an export file for offline analysis\&. The thread supports a graceful shutdown via \fC\fBstop()\fP\fP\&. Logging is performed on a per-instance logger\&. 
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "def \fB__init__\fP (self, str \fBinterface\fP, queue\&.Queue \fBraw_frame\fP=None, \fBrequested_frame\fP=None, str|None \fBexport\fP=None)"
.br
.RI "Initialize CAN sniffer thread and open resources\&. "
.ti -1c
.RI "def \fBexport_raw_frame\fP (self, dict frame, can\&.Message|None msg=None)"
.br
.RI "Save a received CAN frame (raw view) to an export file\&. "
.ti -1c
.RI "def \fBhandle_received_message\fP (self, can\&.Message msg)"
.br
.RI "Handle a received CAN message\&. "
.ti -1c
.RI "def \fBrun\fP (self)"
.br
.RI "Main loop of the sniffer thread\&. "
.ti -1c
.RI "def \fBsend_raw_pdo\fP (self, int cob_id, bytes data)"
.br
.RI "Send raw PDO frame\&. "
.ti -1c
.RI "def \fBsend_sdo_download\fP (self, int node_id, int index, int subindex, int value, int size)"
.br
.RI "Send expedited SDO download (write)\&. "
.ti -1c
.RI "def \fBsend_sdo_upload_request\fP (self, int node_id, int index, int subindex)"
.br
.RI "Send SDO upload request (read)\&. "
.ti -1c
.RI "def \fBstop\fP (self, bool shutdown_bus=True)"
.br
.RI "Request the sniffer thread to stop and optionally shutdown the bus\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBbus\fP"
.br
.RI "CAN bus instance with configuration loading\&. "
.ti -1c
.RI "\fBexport\fP"
.br
.RI "Flag indicating whether export is enabled\&. "
.ti -1c
.RI "\fBexport_file\fP"
.br
.RI "File object for export (or None if not exporting)\&. "
.ti -1c
.RI "\fBexport_filename\fP"
.br
.RI "File name used when export is enabled\&. "
.ti -1c
.RI "\fBexport_serial_number\fP"
.br
.RI "Export serial number (incremented for each exported row)\&. "
.ti -1c
.RI "\fBexport_writer\fP"
.br
.RI "Writer instance used to write exported data (or None)\&. "
.ti -1c
.RI "\fBinterface\fP"
.br
.RI "CAN interface name used by the sniffer\&. "
.ti -1c
.RI "\fBlog\fP"
.br
.RI "Logger instance for this sniffer\&. "
.ti -1c
.RI "\fBnetwork\fP"
.br
.RI "Optional CANopen\&.Network instance (connected if possible)\&. "
.ti -1c
.RI "\fBpcap_writer\fP"
.br
.ti -1c
.RI "\fBraw_frame\fP"
.br
.RI "Queue used to push raw frames for downstream processing\&. "
.ti -1c
.RI "\fBrequested_frame\fP"
.br
.RI "Queue used to receive frames for sending over CAN bus\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "def \fB_dispatch_request\fP (self, dict req)"
.br
.RI "Send request frame on CAN bus\&. "
.ti -1c
.RI "def \fB_ensure_bus\fP (self)"
.br
.RI "Ensure CAN bus is available before transmitting\&. "
.ti -1c
.RI "def \fB_handle_requested_frame\fP (self)"
.br
.RI "Dispatch queued control commands from UI layers\&. "
.ti -1c
.RI "dict \fB_json_safe_raw_frame\fP (self, dict frame)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fB_json_first\fP"
.br
.ti -1c
.RI "\fB_stop_event\fP"
.br
.RI "Thread stop event used to signal the run loop to exit\&. "
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "def __init__ ( self, str interface, queue\&.Queue  raw_frame = \fCNone\fP,  requested_frame = \fCNone\fP, str | None  export = \fCNone\fP)"

.PP
Initialize CAN sniffer thread and open resources\&. The constructor opens the socketcan Bus and attempts to connect a CANopen Network (non-fatal)\&. If export is enabled, the export file and writer are created and a header row is persisted\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterface\fP CAN interface name as string (e\&.g\&., 'can0' or 'vcan0')\&. 
.br
\fIraw_frame\fP \fCqueue\&.Queue\fP instance to push received frames for processing\&. 
.br
\fIexport\fP \fCcsv\fP, \fCjson\fP, \fCpcap\fP: enable export of raw frames to a file\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "def _dispatch_request ( self, dict req)\fC [private]\fP"

.PP
Send request frame on CAN bus\&. 
.SS "def _ensure_bus ( self)\fC [private]\fP"

.PP
Ensure CAN bus is available before transmitting\&. 
.SS "def _handle_requested_frame ( self)\fC [private]\fP"

.PP
Dispatch queued control commands from UI layers\&. 
.SS " dict _json_safe_raw_frame ( self, dict frame)\fC [private]\fP"

.SS "def export_raw_frame ( self, dict frame, can\&.Message | None  msg = \fCNone\fP)"

.PP
Save a received CAN frame (raw view) to an export file\&. Writes a single row with a serial number, timestamp, COB-ID, error flag and raw payload\&. Periodically flushes and fsyncs the file according to \fCdefs\&.FSYNC_EVERY\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIframe\fP Frame to be exported\&. 
.br
\fImsg\fP CANopen message to be exported\&. 
.RE
.PP
\fBReturns\fP
.RS 4
None\&. 
.RE
.PP

.SS "def handle_received_message ( self, can\&.Message msg)"

.PP
Handle a received CAN message\&. 
.PP
.nf
   @details
   Extracts arbitration id, raw payload and error flag, builds a small
   frame dictionary containing a timestamp and pushes it to `raw_frame`.
   Also logs the raw frame and triggers export if enabled.
   @param msg The `can.Message` instance received from the bus.

.fi
.PP
 
.SS "def run ( self)"

.PP
Main loop of the sniffer thread\&. 
.PP
.nf
   @details
   Continuously receives frames from the CAN bus using a short timeout,
   handles interrupt-like exceptions gracefully, and delegates message
   processing to `handle_received_message`. On exit, export file and bus resources
   are closed/shutdown cleanly.

.fi
.PP
 
.SS "def send_raw_pdo ( self, int cob_id, bytes data)"

.PP
Send raw PDO frame\&. 
.PP
.nf
   @param cob_id PDO COB-ID
   @param data Up to 8 bytes

.fi
.PP
 
.SS "def send_sdo_download ( self, int node_id, int index, int subindex, int value, int size)"

.PP
Send expedited SDO download (write)\&. 
.PP
.nf
   @param node_id Node ID (1-127)
   @param index Object Dictionary index
   @param subindex Subindex
   @param value Integer value to write
   @param size Data size in bytes (1,2,4)

.fi
.PP
 
.SS "def send_sdo_upload_request ( self, int node_id, int index, int subindex)"

.PP
Send SDO upload request (read)\&. 
.PP
.nf
   @param node_id Node ID (1-127)
   @param index Object Dictionary index
   @param subindex Subindex

.fi
.PP
 
.SS "def stop ( self, bool  shutdown_bus = \fCTrue\fP)"

.PP
Request the sniffer thread to stop and optionally shutdown the bus\&. Signals the run loop to exit via the internal \fC_stop_event\fP and attempts to shutdown the underlying CAN bus if requested\&. 
.PP
\fBParameters\fP
.RS 4
\fIshutdown_bus\fP If True, call \fCbus\&.shutdown()\fP when stopping\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "_json_first\fC [private]\fP"

.SS "_stop_event\fC [private]\fP"

.PP
Thread stop event used to signal the run loop to exit\&. 
.SS "bus"

.PP
CAN bus instance with configuration loading\&. 
.SS "export"

.PP
Flag indicating whether export is enabled\&. 
.SS "export_file"

.PP
File object for export (or None if not exporting)\&. 
.SS "export_filename"

.PP
File name used when export is enabled\&. 
.SS "export_serial_number"

.PP
Export serial number (incremented for each exported row)\&. 
.SS "export_writer"

.PP
Writer instance used to write exported data (or None)\&. 
.SS "interface"

.PP
CAN interface name used by the sniffer\&. 
.SS "log"

.PP
Logger instance for this sniffer\&. 
.SS "network"

.PP
Optional CANopen\&.Network instance (connected if possible)\&. 
.SS "pcap_writer"

.SS "raw_frame"

.PP
Queue used to push raw frames for downstream processing\&. 
.SS "requested_frame"

.PP
Queue used to receive frames for sending over CAN bus\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for CANopen-Analyzer from the source code\&.
