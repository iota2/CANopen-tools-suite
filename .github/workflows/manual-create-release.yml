name: Create release from tag (manual)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g. v0.2.0). Leave empty to use latest tag.'
        required: false
        default: ''
      base_tag:
        description: 'Base tag to compute release notes from (e.g. v0.1.0). If empty, previous tag is auto-selected.'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (full history and tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Determine tag to release
        id: tagpick
        run: |
          set -euo pipefail
          INPUT_TAG="${{ github.event.inputs.tag }}"
          if [ -n "$INPUT_TAG" ]; then
            TAG="$INPUT_TAG"
          else
            TAG=$(git tag --sort=-v:refname | head -n1)
          fi
          if [ -z "$TAG" ]; then
            echo "No tags found in repository" >&2
            exit 1
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Selected tag: $TAG"

      - name: Determine base tag (previous or provided)
        id: basepick
        run: |
          set -euo pipefail
          INPUT_BASE="${{ github.event.inputs.base_tag }}"
          TAG="${{ steps.tagpick.outputs.tag }}"

          if [ -n "$INPUT_BASE" ]; then
            BASE="$INPUT_BASE"
            echo "Using provided base_tag: $BASE"
          else
            TAG_LIST=$(git tag --sort=-v:refname)
            BASE=""
            found=0
            while IFS= read -r t; do
              if [ "$found" -eq 1 ]; then
                BASE="$t"
                break
              fi
              if [ "$t" = "$TAG" ]; then
                found=1
              fi
            done <<< "$TAG_LIST"

            if [ -z "$BASE" ]; then
              echo "No previous tag found; base will be empty (release will include full history up to $TAG)"
            else
              echo "Auto-detected previous tag: $BASE"
            fi
          fi

          echo "base=${BASE:-}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes from CHANGELOG.md (range: base_tag..tag) â€” fallback to git log
        id: gen_notes
        run: |
          set -euo pipefail

          TAG="${{ steps.tagpick.outputs.tag }}"
          BASE="${{ steps.basepick.outputs.base }}"
          echo "Selected tag: $TAG"
          if [ -n "$BASE" ]; then
            echo "Base tag: $BASE"
          else
            echo "Base tag: <none>"
          fi

          TAG_STRIPPED="${TAG#v}"
          BASE_STRIPPED="${BASE#v}"

          RELEASE_BODY=""
          COMPARE_URL=""

          if [ -f CHANGELOG.md ]; then
            # robust header matcher: supports
            #   ## [v0.1.0] - ...
            #   ## [0.1.0] - ...
            #   ## v0.1.0 - ...
            #   ## 0.1.0 - ...
            HEADER_RE="^##[[:space:]]*(?:\\[v?${TAG_STRIPPED}\\]|v?${TAG_STRIPPED})"
            START_LINE=$(grep -n -E "$HEADER_RE" CHANGELOG.md | head -n1 | cut -d: -f1 || true)

            if [ -n "$START_LINE" ]; then
              echo "Found CHANGELOG section start for ${TAG} at line ${START_LINE}"

              if [ -n "$BASE" ]; then
                BASE_HEADER_RE="^##[[:space:]]*(?:\\[v?${BASE_STRIPPED}\\]|v?${BASE_STRIPPED})"
                START_BASE_LINE=$(grep -n -E "$BASE_HEADER_RE" CHANGELOG.md | head -n1 | cut -d: -f1 || true)
                if [ -n "$START_BASE_LINE" ]; then
                  END_LINE=$(( START_BASE_LINE - 1 ))
                else
                  echo "Base tag ${BASE} not found in CHANGELOG.md; will extract until EOF"
                  END_LINE=$(wc -l < CHANGELOG.md)
                fi
              else
                # find next '## ' header after START_LINE
                NEXT_REL=$(tail -n +"$((START_LINE+1))" CHANGELOG.md | grep -n -E '^##[[:space:]]*' | head -n1 | cut -d: -f1 || true)
                if [ -n "$NEXT_REL" ]; then
                  END_LINE=$(( START_LINE + NEXT_REL - 1 ))
                else
                  END_LINE=$(wc -l < CHANGELOG.md)
                fi
              fi

              echo "Extracting CHANGELOG lines ${START_LINE}..${END_LINE}"
              sed -n "${START_LINE},${END_LINE}p" CHANGELOG.md > release_body.txt

              if [ -n "$BASE" ]; then
                COMPARE_URL="https://github.com/${{ github.repository }}/compare/${BASE}...${TAG}"
              else
                COMPARE_URL="https://github.com/${{ github.repository }}/tree/${TAG}"
              fi

              {
                echo "Changes in ${TAG}"
                echo
                echo "${COMPARE_URL}"
                echo
                cat release_body.txt
              } > release_body.txt.tmp
              mv release_body.txt.tmp release_body.txt
              RELEASE_BODY="$(cat release_body.txt)"
            else
              echo "No matching section found for ${TAG} in CHANGELOG.md"
            fi
          else
            echo "CHANGELOG.md not found; will fallback to git log"
          fi

          # fallback to git log if extraction failed
          if [ -z "${RELEASE_BODY}" ]; then
            if [ -n "$BASE" ]; then
              RANGE="${BASE}..${TAG}"
              COMPARE_URL="https://github.com/${{ github.repository }}/compare/${BASE}...${TAG}"
              echo "Generating notes from git log for range: ${RANGE}"
              NOTES=$(git log --pretty=format:'- %s (%an)' "${RANGE}" || true)
            else
              COMPARE_URL="https://github.com/${{ github.repository }}/tree/${TAG}"
              echo "Generating notes from git log up to tag: ${TAG}"
              NOTES=$(git log --pretty=format:'- %s (%an)' "${TAG}" || true)
            fi

            if [ -z "$NOTES" ]; then
              BODY="No changelog entries (no commits in range)."
            else
              BODY="Changes in ${TAG}\n\n${COMPARE_URL}\n\n${NOTES}"
            fi
            printf "%s\n" "$BODY" > release_body.txt
          fi

          # Emit the multiline body as step output
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          cat release_body.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          # extra debugging outputs
          echo "notes_written=true" >> "$GITHUB_OUTPUT"
          echo "compare_url=${COMPARE_URL}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release
        uses: actions/create-release@v1
        with:
          tag_name: "${{ steps.tagpick.outputs.tag }}"
          release_name: "${{ steps.tagpick.outputs.tag }}"
          body: "${{ steps.gen_notes.outputs.body }}"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
