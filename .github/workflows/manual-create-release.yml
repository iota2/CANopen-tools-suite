name: Create release from tag (manual)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g. v0.2.0). Leave empty to use latest tag.'
        required: false
        default: ''
      base_tag:
        description: 'Base tag to compute release notes from (e.g. v0.1.0). If empty, previous tag is auto-selected.'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history and tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Determine tag to release
        id: tagpick
        run: |
          set -euo pipefail
          INPUT_TAG="${{ github.event.inputs.tag }}"
          if [ -n "$INPUT_TAG" ]; then
            TAG="$INPUT_TAG"
          else
            TAG=$(git tag --sort=-v:refname | head -n1)
          fi
          if [ -z "$TAG" ]; then
            echo "No tags found in repository" >&2
            exit 1
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Selected tag: $TAG"

      - name: Determine base tag (previous or provided)
        id: basepick
        run: |
          set -euo pipefail
          INPUT_BASE="${{ github.event.inputs.base_tag }}"
          TAG="${{ steps.tagpick.outputs.tag }}"
          if [ -n "$INPUT_BASE" ]; then
            BASE="$INPUT_BASE"
            echo "Using provided base_tag: $BASE"
          else
            # Find previous tag (by semver sort). We want the tag immediately after TAG in descending order.
            # Build ordered list and find the item after TAG.
            TAG_LIST=$(git tag --sort=-v:refname)
            PREV=$(echo "$TAG_LIST" | awk -v t="$TAG" '{
              arr[NR] = $0
            }
            END {
              for(i=1;i<=NR;i++){
                if(arr[i]==t && i<NR){ print arr[i+1]; exit }
              }
            }')
            BASE="$PREV"
            if [ -z "$BASE" ]; then
              echo "No previous tag found; base will be empty (release will include full history up to $TAG)"
            else
              echo "Auto-detected previous tag: $BASE"
            fi
          fi
          echo "base=$BASE" >> "$GITHUB_OUTPUT"

      - name: Generate release notes from CHANGELOG.md (range: base_tag..tag) â€” fallback to git log
        id: gen_notes
        run: |
          set -euo pipefail
          TAG="${{ steps.tagpick.outputs.tag }}"
          BASE="${{ steps.basepick.outputs.base }}"
          echo "Selected tag: $TAG"
          echo "Base tag: ${BASE:-<none>}"

          TAG_STRIPPED="${TAG#v}"
          BASE_STRIPPED="${BASE#v}"

          RELEASE_BODY=""
          COMPARE_URL=""

          if [ -f CHANGELOG.md ]; then
            # Find start line of the TAG section (matches "## [vX.Y.Z]" or "## [X.Y.Z]") :
            START_LINE=$(grep -n -E "^##\s*\[?v?${TAG_STRIPPED}\]?" CHANGELOG.md | head -n1 | cut -d: -f1 || true)
            if [ -n "$START_LINE" ]; then
              echo "Found changelog section start for ${TAG} at line ${START_LINE}"
              # If BASE is provided/found in changelog, find its start line; we'll extract from START_LINE..(START_BASE-1)
              if [ -n "$BASE" ]; then
                START_BASE_LINE=$(grep -n -E "^##\s*\[?v?${BASE_STRIPPED}\]?" CHANGELOG.md | head -n1 | cut -d: -f1 || true)
                if [ -n "$START_BASE_LINE" ]; then
                  echo "Found changelog section start for base ${BASE} at line ${START_BASE_LINE}"
                  END_LINE=$(( START_BASE_LINE - 1 ))
                else
                  echo "Base tag ${BASE} not found in CHANGELOG.md; will extract until EOF"
                  END_LINE=$(wc -l < CHANGELOG.md)
                fi
              else
                # no base specified: find next '## [' header after START_LINE to end extraction
                NEXT_REL=$(tail -n +"$((START_LINE+1))" CHANGELOG.md | grep -n -E '^##\s*\[' | head -n1 | cut -d: -f1 || true)
                if [ -n "$NEXT_REL" ]; then
                  END_LINE=$(( START_LINE + NEXT_REL - 1 ))
                else
                  END_LINE=$(wc -l < CHANGELOG.md)
                fi
              fi

              echo "Extracting CHANGELOG lines ${START_LINE}..${END_LINE}"
              sed -n "${START_LINE},${END_LINE}p" CHANGELOG.md > release_body.txt

              # Build compare URL
              if [ -n "$BASE" ]; then
                COMPARE_URL="https://github.com/${{ github.repository }}/compare/${BASE}...${TAG}"
              else
                COMPARE_URL="https://github.com/${{ github.repository }}/tree/${TAG}"
              fi

              {
                echo "Changes in ${TAG}"
                echo
                echo "${COMPARE_URL}"
                echo
                cat release_body.txt
              } > release_body.txt.tmp
              mv release_body.txt.tmp release_body.txt
              RELEASE_BODY="$(cat release_body.txt)"
            else
              echo "No matching ## [${TAG}] section found in CHANGELOG.md"
            fi
          else
            echo "CHANGELOG.md not found; will fallback to git log"
          fi

          # Fallback to git log if no changelog section was found or file missing
          if [ -z "${RELEASE_BODY}" ]; then
            if [ -n "$BASE" ]; then
              RANGE="${BASE}..${TAG}"
              COMPARE_URL="https://github.com/${{ github.repository }}/compare/${BASE}...${TAG}"
              echo "Generating notes from git log for range: ${RANGE}"
              NOTES=$(git log --pretty=format:'- %s (%an)' "${RANGE}" || true)
            else
              COMPARE_URL="https://github.com/${{ github.repository }}/tree/${TAG}"
              echo "Generating notes from git log up to tag: ${TAG}"
              NOTES=$(git log --pretty=format:'- %s (%an)' "${TAG}" || true)
            fi

            if [ -z "$NOTES" ]; then
              BODY="No changelog entries (no commits in range)."
            else
              BODY="Changes in ${TAG}\n\n${COMPARE_URL}\n\n${NOTES}"
            fi
            echo -e "$BODY" > release_body.txt
          fi

          # Emit the multiline body as a step output
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          cat release_body.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          # export summary outputs
          echo "notes_written=true" >> "$GITHUB_OUTPUT"
          echo "compare_url=${COMPARE_URL}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release
        uses: actions/create-release@v1
        with:
          tag_name: "${{ steps.tagpick.outputs.tag }}"
          release_name: "${{ steps.tagpick.outputs.tag }}"
          body: "${{ steps.gen_notes.outputs.body }}"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
